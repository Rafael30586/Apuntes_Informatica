git config --global user.name "<nombre>" --> configura el nombre de usuario de manera global.

git config --global user.email "<email>" --> configura el email de manera global.

git config --list --> muestra información como nombre de usuario, email, etc.

git config --list <opcion> --> muestra las configuraciones según la opción que elijamos. LAs opciones pueden ser --local, --global o --system

git config --get-regexp <secuencia> --> muestra configuraciones que contengan la secuencia de caracteres que queramos, por ejemplo: git config --get-regexp user , esto mostrará datos como user.name y user.email.

git init --> inicializa un repositorio de git en la carpeta en la que estamos. Se crea una carpeta oculta .git en el directorio.

git branch -m <nombre> --> podemos cambiarle el nombre a la rama main o master.

git add <archivo> --> añade el archivo que indiquemos a la staged área.

git add . --> añade todos los archivos del directorio al staged área.

git status --> muestra el estado actual del directorio: archivos modificados, staging área, etc.

git status -s --> como el anterior pero es una versión más corta.

git restore <archivo> --> devuelve un archivo a su estado anterior a ser modificado. Esto funciona cuando los archivos han sido modificados pero no están en el estado staged.

git restore --staged <archivo> --> quita un archivo del estado staged.

git commit -m "<mensaje>" --> realiza un commit con un mensaje que indiquemos.

git rm <archivo> --> borra un archivo.

git rm --cached <archivo> --> para de rastrear un archivo.

git log --> muestra los commits relizados hasta ahora.

git log --graph --> muestra los commits realizados hasta ahora de una manera más gráfica.

git log --pretty=oneline --> muestra los commits de una manera más compacta.

En la documentación de git se hace referencia al working tree y el index. Aparentemente el index son los archivos que están "commited". El working tree tiene que ver con los archivos dentro de la carpeta estén o no "commited". 

working tree o working directory: es donde modificamos y editamos archivos. Los cambios no son rastreados hasta que los pasamos al estado stage.

staging area o index: se usa git add para mover los archivos del working tree hasta el staging area. Esto crea una "fotografía" de los archivos que van a aparecer en el próximo commit.

repositorio local o directorio de git: se usa git commit para guardar permanentemente la fotografía que está en el index en la historia del repositorio.

git reset --> saca a los archivos del staging área.

git config --global alias.<alias> "<comando>" --> podemos asignarle un alias a un comando que elijamos.

git config --global --unset alias.<alias> --> así podemos borrar un alias que hayamos creado de manera global.

git diff --> muestra las diferencias que hay entre los archivos editados y el commit anterior. Las nuevas líneas de código se muestran en verde, en blanco se muestran las que quedaron igual y en rojo muestra las que ya no están.

git checkout <archivo> --> borra los cambios producidos en un archivo. El archivo vuelve a ser como en el último commit.

git checkout <numero_de_commit> --> nos lleva al commit que queramos pero la cabeza queda separada de la rama master. Podemos volver a master con git Branch.

En git, al igual que en Linux, se puede utilizar opciones cuando ejecutamos comandos. Por ejemplo -m cuando hacemos un commit es una opción y el mensaje que colocamos entre comillas sería el argumento. Cuando una opción es booleana se le puede llamar flag, por ejemplo, --list. Cuando las opciones llevan un solo guión serían la opción corta y cuando llevan dos guiones medios serían la opción larga. Las opciones cortas pueden, a veces, agruparse, por ejemplo ls -la. Las opciones largas son más legibles pero no pueden agruparse, algunas tienen una versión corta.

git reset --hard <número_de_commit> --> nos lleva al commit que indiquemos y borra los posteriores, de todas formas podemos volver a tener los commits borrados ayudándonos con git reflog, ya que contiene el historial completo. Podemos hacer git reset --hard con commits que estén en el reflog.

git reflog --> es el historial completo de interacciones en nuestro working tree. 

git tag <nombre> --> le otorga una etiqueta al commit actual.

git checkout tags/<tag> --> nos lleva hasta el tag que indiquemos pero la cabeza se desprende de la rama master.

git branch <nombre> --> crea una rama con el nombre que indiquemos.

git switch <rama> --> cambia de rama.

Si realizamos cambios en un archivo de una rama sin hacer commit, git no nos dejará cambiar de rama a menos que hagamos el commit o que usemos git stash.

git stash --> guarda cambios producidos en una rama sin hacer commit. 

git stash list --> muestra los stash que hayamos hecho hasta ahora.

git stash pop --> recupera los cambios que habíamos hecho con git stash.

git stash drop --> borra el stash de la rama actual.

git diff <rama> --> compara la rama que elijamos con la rama en la que estamos.

git branch -d <rama> --> borra una rama que indiquemos.

git fetch --> descarga el historial de cambios sin descargar los cambios.

git pull --> descarga el historial y los cambios.

git pull -u origin <rama> --> descarga una rama a nuestro repositorio local.

git clone <url> --> clona un repositorio remoto y lo deja en local.

git push -u origin <rama> --> copia la rama en la que estamos trabajando en local en el repositorio remoto.

origin: es el alias que git asigna automáticamente al repositorio remoto desde el cual se clonó el proyecto, sirviendo como un atajo o marcador para la URL de ese servidor. Al ejecutar git clone <URL>, git configura automáticamente origin para apuntar a esa URL. 

git remote -v --> nos muestra a que URL apunta origin.

git push --> guarda los cambios producidos en la rama del repositorio local en el remoto.

git cherry-pick <id_de_commit> --> trae a la rama en la que estamos los cambios de un commit de una rama que elijamos. Puede que haya conflictos y tendremos que solucionarlos.

Detached HEAD: 
En condiciones normales, HEAD apunta a una rama y esa rama apunta a un commit, por ejemplo HEAD -> main -> C3. El detached head ocurre cuando HEAD deja de apuntar a una rama y apunta a un commit. En este estado se pueden hacer commits si uno lo desea, pero esos commits no pertenecen a ninguna rama. Si luego cambiamos a la rama main el commit que hayamos hecho en ese estado queda "flotando". El commit no se pierde inmediatamente (git lo mantiene en el reflog por un tiempo), pero si no se lo referencia con una rama, eventualmente puede ser recolectado por el recolector de basura. Estar en detached HEAD puede servir para: probar versiones antiguas; hacer debugging; revisar un tag; probar algo sin afectar ramas.

git show HEAD --> muestra la ubicación del HEAD y su estado.

git ls-tree -r --name-only <commit> --> muestra los archivos que están commiteados en el commit que indiquemos

git config --global alias.<nombre> "<comandos>" --> crea una alias según el nombre y los comandos que le indiquemos.